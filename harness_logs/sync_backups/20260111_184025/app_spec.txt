# Noodle 2 — Product Description

## Executive Summary

**Noodle 2** is a safety-aware, policy-driven orchestration system for large-scale physical-design (PD) experimentation built on top of OpenROAD. It manages *uncertainty, failure, and limited compute budgets* while exploring Engineering Change Orders (ECOs) across complex, multi-stage design workflows.

Noodle 2 does **not** replace PD tools or algorithms. Instead, it provides a deterministic control plane that enables structured experimentation, auditable decision-making, and safe automation across multiple studies, stages, and design variants.

---

## Positioning

Noodle 2 occupies the layer **above** physical-design engines such as OpenROAD:

* OpenROAD solves placement, routing, and timing problems.
* Noodle 2 decides **what to try, when to stop, and what to trust**.

It acts as a *safety-critical experiment controller* rather than an optimizer or solver.

---

## Core Concepts

### Study

A **Study** is the top-level unit of work in Noodle 2.

A Study defines:

* a base design snapshot (e.g., Nangate45, ASAP7, Sky130)
* a safety domain
* policy and rail configuration
* one or more multi-stage experiment graphs

Studies are isolated by default: telemetry, priors, and outcomes do not leak across studies unless explicitly allowed via warm-start configuration.

**Study Definition Schema**:

```yaml
# study_definition.yaml
study:
  name: nangate45_extreme_fix
  version: "1.0"
  pdk: nangate45
  safety_domain: guarded

  snapshot:
    path: ./snapshots/nangate45_extreme
    hash: sha256:abc123def456...

  objective:
    mode: pareto                    # "pareto", "weighted_sum", or "lexicographic"
    primary: wns_ps
    secondary: hot_ratio
    weights: [0.7, 0.3]

  diagnosis:
    enabled: true
    timing_paths: 20
    hotspot_threshold: 0.7

  visualization:
    enabled: true
    heatmaps: [placement_density, routing_congestion, rudy]
    differential: true
    critical_path_overlay: true
    pareto_frontier: true

  stages:
    - name: exploration
      mode: sta_only
      budget: 50
      survivors: 10
      eco_classes: [topology_neutral, placement_local]

    - name: refinement
      mode: sta_congestion
      budget: 30
      survivors: 3
      eco_classes: [placement_local, routing_affecting]

    - name: closure
      mode: full_verification
      budget: 10
      survivors: 1
      eco_classes: [topology_neutral, placement_local]

  rails:
    abort:
      wns_ps: -10000
      timeout_seconds: 600
    stage:
      failure_rate: 0.8
    study:
      catastrophic_failures: 5
      max_runtime_hours: 4

  checkpointing:
    enabled: true
    interval: per_stage

  priors:
    mode: warm_start               # "fresh" or "warm_start"
    source_studies: []             # list of prior study names
```

---

### Case

A **Case** represents a concrete design state derived from a Study.

* The **base Case** is the original snapshot.
* **Derived Cases** are created by applying one or more ECOs.
* Cases form a directed acyclic graph (DAG) within a Study.

**Deterministic naming contract**:

```
<case_name>_<stage_index>_<derived_index>
```

Examples:
* `nangate45_0_0` — base case, stage 0
* `nangate45_1_3` — stage 1, derived case 3

This guarantees traceable lineage across complex branching experiments.

---

### Stage

A **Stage** is a refinement phase within a Study.

* Studies may define any number of ordered stages (`N >= 1`).
* Each stage specifies:

  * **execution mode** (e.g., STA-only, STA+congestion)
  * **trial budget**: maximum number of ECO trials to attempt
  * **survivor count**: how many top-performing Cases advance to the next stage
  * **allowed ECO classes**: which risk categories of ECOs may be applied
  * **abort thresholds**: metric limits that trigger early termination
  * **safety rails**: hard limits that cannot be exceeded
  * **approval gate** (optional): require human approval before proceeding

**Survivor Selection**:

At stage completion, Cases are ranked and selected using configurable methods:

| Method | Description |
|--------|-------------|
| `pure_top_n` | Select N best by objective function |
| `diverse_top_n` | Select N best while maintaining diversity |
| `tournament` | Tournament selection with randomness |
| `pareto_front` | Select cases on the Pareto frontier |

**Diversity-Aware Selection**:

```yaml
survivor_selection:
  method: diverse_top_n
  count: 5
  diversity:
    enabled: true
    metric: eco_path_distance    # how different the ECO sequences are
    min_diversity: 0.3           # minimum distance between survivors
  elitism:
    always_keep_best: true
    random_survivors: 1          # keep 1 random survivor for exploration
```

Stages execute sequentially; only surviving Cases advance.

---

### ECO (Engineering Change Order)

An **ECO** is a first-class, auditable unit of change.

Each ECO:

* has a stable name and classification
* emits metrics, logs, and failure semantics
* is comparable across Cases and Studies
* belongs to an explicit ECO class with a defined risk envelope

**ECO Definition Schema**:

```yaml
eco:
  name: resize_critical_drivers
  eco_class: placement_local
  description: Upsize cells on critical timing paths

  # When to consider this ECO (auto-diagnosis integration)
  preconditions:
    requires_timing_issue: true
    wns_ps_worse_than: -500
    hot_ratio_below: 0.5          # don't apply if congestion is the main problem

  # TCL template with parameters
  tcl_template: |
    # Find critical paths
    set paths [find_timing_paths -max_paths {{ max_paths }}]

    foreach path $paths {
      set driver [get_driver $path]
      set current_size [get_cell_size $driver]
      set new_size [expr {$current_size * {{ size_multiplier }}}]

      # Resize if within bounds
      if {$new_size <= {{ max_size }}} {
        resize_cell $driver -size $new_size
      }
    }

  # Configurable parameters
  parameters:
    max_paths:
      type: int
      default: 10
      range: [5, 50]
    size_multiplier:
      type: float
      default: 1.5
      range: [1.1, 2.0]
    max_size:
      type: float
      default: 4.0

  # Expected effects (for auto-diagnosis suggestions)
  expected_effects:
    wns_ps: improve
    tns_ps: improve
    area_um2: increase_slightly
    power_mw: increase_slightly

  # Post-execution verification
  postconditions:
    wns_must_improve: true
    no_new_drc_violations: true

  timeout_seconds: 300
```

**Compound ECOs**:

Multiple ECOs can be composed into a single unit:

```yaml
compound_eco:
  name: timing_rescue_combo
  description: Combined aggressive timing fix

  components:
    - eco: resize_critical_drivers
      parameters:
        size_multiplier: 1.3
        max_paths: 20
    - eco: insert_buffers
      parameters:
        max_buffers: 50
    - eco: swap_to_faster_cells
      parameters:
        path_count: 10

  apply_order: sequential
  rollback_on_failure: all        # "all", "partial", or "none"

  eco_class: placement_local      # inherited from most restrictive component
```

ECOs do not modify OpenROAD internals and are executed through standardized helper APIs.

---

### Rails (Policy Limits)

**Rails** are hard policy limits that constrain Noodle 2's behavior. Unlike soft thresholds that trigger warnings, rails trigger immediate action.

Rail types:

* **abort_rail**: if crossed, stop the current trial immediately
* **stage_rail**: if crossed, terminate the entire stage
* **study_rail**: if crossed, halt the entire Study

Example rail configuration:

```yaml
rails:
  abort:
    wns_ps: -5000             # abort trial if WNS worse than -5ns
    timeout_seconds: 600      # abort trial if exceeds 10 minutes
  stage:
    failure_rate: 0.8         # stop stage if 80% of trials fail
  study:
    catastrophic_failures: 3  # stop study after 3 catastrophic failures
    max_runtime_hours: 8      # stop study after 8 hours total
```

---

### Priors (ECO Effectiveness History)

**Priors** track the historical effectiveness of ECOs within a Study.

Prior states:

* **unknown**: ECO has not been executed yet (default initial state)
* **trusted**: ECO has consistently improved metrics without failures
* **mixed**: ECO has shown variable results (some improvements, some regressions)
* **suspicious**: ECO has caused failures or significant regressions

Priors influence ECO selection and trial ordering. Suspicious ECOs may be deprioritized or excluded based on safety domain.

**Warm Start** (Cross-Study Prior Transfer):

```yaml
priors:
  mode: warm_start
  source_studies:
    - name: nangate45_fix_v1
      weight: 0.8
    - name: nangate45_fix_v2
      weight: 0.5
  decay: 0.9                      # reduce confidence for older priors
  conflict_resolution: newest     # "newest", "highest_weight", or "average"
```

---

### Promotion Rules

**Promotion rules** govern when and how Cases advance through stages:

* **metric_threshold**: Case must meet minimum improvement targets
* **relative_ranking**: Case must be in top N by objective function
* **pareto_membership**: Case must be on the Pareto frontier
* **safety_clearance**: Case must not have triggered any rails
* **stability_check**: Case must produce consistent results across repeated trials (optional)

---

## Safety Model

### Safety Domains

Every Study runs under a declared **Safety Domain**:

| Domain | Description | Use Case |
|--------|-------------|----------|
| `sandbox` | Exploratory, permissive; all ECO classes allowed | Early experimentation |
| `guarded` | Default, production-like; moderate restrictions | Standard development |
| `locked` | Conservative, regression-only; minimal changes allowed | Pre-tapeout, CI gates |

Safety Domains constrain:

* allowed ECO classes
* abort sensitivity (how quickly to stop on anomalies)
* promotion rules (how strict the advancement criteria)
* use of historical priors (whether to trust past results)

---

### ECO Classes

ECOs are categorized by **blast radius** (scope of potential impact):

| Class | Description | Typical Operations | Risk Level |
|-------|-------------|-------------------|------------|
| `topology_neutral` | No netlist changes | Timing analysis, reporting | Lowest |
| `placement_local` | Cell movement within small region | Buffer insertion, gate sizing | Low |
| `routing_affecting` | May require route updates | Net restructuring, pin swaps | Medium |
| `global_disruptive` | Major structural changes | Floorplan modification, macro moves | Highest |

**Safety Domain ECO Restrictions**:

| Domain | Allowed ECO Classes |
|--------|---------------------|
| `sandbox` | All classes |
| `guarded` | `topology_neutral`, `placement_local`, `routing_affecting` |
| `locked` | `topology_neutral`, `placement_local` only |

---

### Legality & Guardrails

Before execution, Noodle 2 produces a **Run Legality Report** summarizing:

* declared safety domain
* proposed ECO classes
* applicable rails
* abort criteria

**Illegal runs are rejected before consuming compute.**

Example legality check failure:

```
LEGALITY CHECK FAILED
  Safety domain: locked
  Requested ECO class: global_disruptive
  Reason: global_disruptive ECOs not permitted in locked domain
  Action: Run rejected
```

---

## Auto-Diagnosis

Noodle 2 includes an **auto-diagnosis** system that analyzes design metrics to identify root causes and suggest appropriate ECOs.

### Timing Diagnosis

```yaml
diagnosis:
  timing:
    enabled: true
    analyze_critical_paths: true
    path_count: 20
    classify_bottleneck: true     # wire-dominated vs cell-dominated
    identify_problem_cells: true
    slack_histogram: true
```

**Timing Diagnosis Output**:

```json
{
  "timing_diagnosis": {
    "wns_ps": -2150,
    "tns_ps": -45000,
    "failing_endpoints": 234,

    "dominant_issue": "wire_dominated",
    "confidence": 0.85,

    "critical_region": {
      "bbox": {"x1": 100, "y1": 150, "x2": 200, "y2": 250},
      "description": "northeast quadrant near macro M1"
    },

    "problem_nets": [
      {"name": "data_bus[31]", "slack_ps": -2150, "wire_delay_pct": 78},
      {"name": "data_bus[30]", "slack_ps": -1980, "wire_delay_pct": 72}
    ],

    "suggested_ecos": [
      {"eco": "insert_buffers", "priority": 1, "reason": "wire-dominated paths"},
      {"eco": "spread_dense_region", "priority": 2, "reason": "reduce detours"}
    ],

    "slack_histogram": {
      "bins_ps": [-3000, -2000, -1000, 0],
      "counts": [12, 45, 177, 1024]
    }
  }
}
```

### Congestion Diagnosis

```yaml
diagnosis:
  congestion:
    enabled: true
    identify_hotspots: true
    hotspot_threshold: 0.7
    correlate_with_placement: true
    analyze_layer_distribution: true
```

**Congestion Diagnosis Output**:

```json
{
  "congestion_diagnosis": {
    "hot_ratio": 0.35,
    "overflow_total": 1247,

    "hotspot_count": 3,
    "hotspots": [
      {
        "id": 1,
        "bbox": {"x1": 50, "y1": 200, "x2": 100, "y2": 250},
        "severity": "critical",
        "cause": "pin_crowding",
        "affected_layers": ["metal3", "metal4"],
        "suggested_ecos": ["reroute_congested_nets", "spread_dense_region"]
      },
      {
        "id": 2,
        "bbox": {"x1": 150, "y1": 100, "x2": 200, "y2": 150},
        "severity": "moderate",
        "cause": "placement_density",
        "affected_layers": ["metal2", "metal3"],
        "suggested_ecos": ["spread_dense_region"]
      }
    ],

    "layer_breakdown": {
      "metal2": {"usage_pct": 85, "overflow": 234},
      "metal3": {"usage_pct": 92, "overflow": 567},
      "metal4": {"usage_pct": 78, "overflow": 123}
    },

    "correlation_with_placement": {
      "placement_density_correlation": 0.72,
      "macro_proximity_correlation": 0.45
    }
  }
}
```

### Combined Diagnosis Report

The auto-diagnosis system produces a combined report that drives ECO selection:

```json
{
  "diagnosis_summary": {
    "primary_issue": "timing",
    "secondary_issue": "congestion",

    "recommended_strategy": "timing_first",
    "reasoning": "WNS is severe (-2150ps), congestion is moderate (0.35). Fix timing first, then address residual congestion.",

    "eco_priority_queue": [
      {"eco": "insert_buffers", "priority": 1, "addresses": "timing"},
      {"eco": "resize_critical_drivers", "priority": 2, "addresses": "timing"},
      {"eco": "spread_dense_region", "priority": 3, "addresses": "both"},
      {"eco": "reroute_congested_nets", "priority": 4, "addresses": "congestion"}
    ]
  }
}
```

---

## Experiment Control

### Multi-Stage Execution

Noodle 2 supports **arbitrary N-stage experiment graphs**:

* coarse exploration -> focused refinement -> conservative closure
* per-stage policy binding
* per-stage safety evaluation
* optional human approval gates

Example 4-stage flow with approval gate:

```yaml
stages:
  - name: exploration
    mode: sta_only
    budget: 50
    survivors: 10
    eco_classes: [topology_neutral, placement_local]
    visualization:
      heatmaps: true
      differential: false         # no baseline yet

  - name: refinement
    mode: sta_congestion
    budget: 30
    survivors: 3
    eco_classes: [placement_local, routing_affecting]
    visualization:
      heatmaps: true
      differential: true
      pareto_frontier: true

  - name: approval_gate
    type: human_approval
    timeout_hours: 24
    show_summary: true
    show_visualizations: true
    required_approvers: 1
    message: "Review results before aggressive ECOs"

  - name: aggressive_closure
    mode: full_verification
    budget: 15
    survivors: 1
    eco_classes: [placement_local, routing_affecting]
    requires_approval: approval_gate
    visualization:
      heatmaps: true
      differential: true
      critical_path_overlay: true
```

This generalizes traditional Stage 1 / Stage 2 flows without loss of determinism.

---

### Failure Detection & Containment

Each trial is deterministically classified immediately after execution.

**Early Failure Classification**:

| Type | Severity | Description |
|------|----------|-------------|
| `tool_crash` | critical | OpenROAD process exited non-zero |
| `timeout` | high | Trial exceeded time limit |
| `parse_failure` | high | Required output files missing or malformed |
| `metric_regression` | medium | Metrics significantly worse than baseline |
| `rail_violation` | medium | Trial crossed an abort rail |
| `postcondition_failure` | medium | ECO postconditions not satisfied |
| `visualization_unavailable` | low | Heatmap export failed (non-blocking) |

**Containment Scopes**:

Failures are contained at the appropriate scope:

* **individual ECO**: mark ECO prior as suspicious, continue stage
* **ECO class**: disable entire class for remainder of stage
* **stage**: abort stage, advance only current survivors
* **entire Study**: halt all execution, require human review

---

### Adaptive Policy with Memory

Within a Study, Noodle 2 maintains structured memory:

* ECO effectiveness history (priors)
* early-failure statistics per ECO and ECO class
* catastrophic failure markers
* diagnosis history (what issues were detected and fixed)

Policies adapt conservatively based on evidence while remaining inspectable and deterministic.

**Adaptation Rules**:

```
IF eco.consecutive_failures >= 3:
    eco.prior = "suspicious"

IF eco_class.failure_rate > 0.5:
    eco_class.deprioritize()

IF stage.catastrophic_failures >= study.rail.catastrophic_failures:
    study.halt("rail_violation")

IF eco.postcondition_failures >= 2:
    eco.prior = "mixed"
    eco.requires_diagnosis_match = true  # only apply when diagnosis suggests it
```

---

### Checkpoint & Resume

Noodle 2 supports checkpointing for long-running studies:

```yaml
checkpointing:
  enabled: true
  interval: per_stage            # "per_stage", "per_trial", or "hourly"
  location: ./checkpoints/
  retention: 3                   # keep last 3 checkpoints
  include_artifacts: false       # artifacts stored separately
```

**Checkpoint Contents**:

```
checkpoints/
  nangate45_fix/
    stage_0_complete.noodle      # checkpoint file
    stage_1_complete.noodle
    latest -> stage_1_complete.noodle
```

**CLI**:

```bash
# Resume from latest checkpoint
noodle2 resume --study nangate45_fix

# Resume from specific checkpoint
noodle2 resume --checkpoint ./checkpoints/nangate45_fix/stage_0_complete.noodle

# List available checkpoints
noodle2 checkpoints --study nangate45_fix
```

---

### Replay & Debug Mode

Noodle 2 supports replaying specific trials for debugging:

```bash
# Replay specific trial with verbose output
noodle2 replay --study nangate45_fix --case nangate45_1_5 --verbose

# Replay with modified ECO parameters
noodle2 replay --study nangate45_fix --case nangate45_1_3 \
  --eco resize_critical_drivers \
  --param size_multiplier=1.8

# Replay with full visualization (even if originally disabled)
noodle2 replay --case nangate45_1_5 --force-visualization

# Generate detailed debug report
noodle2 debug --case nangate45_1_5 --output debug_report/
```

**Debug Report Contents**:

```
debug_report/
  case_nangate45_1_5/
    execution_trace.json         # step-by-step execution log
    tcl_commands.log             # exact TCL sent to OpenROAD
    openroad_stdout.log          # full OpenROAD output
    openroad_stderr.log
    metrics_before.json
    metrics_after.json
    diagnosis_at_execution.json
    eco_parameters_used.json
    all_heatmaps/                # full visualization set
```

---

## Telemetry & Auditability

Noodle 2 emits structured telemetry across three axes:

* **Study-level**: overall progress, final outcomes, aggregate statistics
* **Stage-level**: survivor selection, failure rates, timing improvements
* **Case-level**: individual trial results, ECO effectiveness, metric deltas

**Artifact Bundle Structure**:

```
artifacts/
  <study_name>/
    study_summary.json
    study_config.yaml              # frozen study definition
    diagnosis_history.json         # all diagnosis reports
    pareto_history.json            # Pareto frontier evolution

    <case_name>/
      <stage_index>/
        <trial_index>/
          artifact_index.json      # manifest of all artifacts
          metrics.json             # parsed timing/congestion metrics
          diagnosis.json           # auto-diagnosis for this state
          timing_report.txt        # raw report_checks output
          congestion_report.txt    # raw global_route output
          eco_applied.json         # ECO details and parameters

          visualizations/          # all visualization artifacts
            heatmaps/
              placement_density.csv
              placement_density.png
              routing_congestion.csv
              routing_congestion.png
              rudy.csv
              rudy.png
            differential/          # comparison with parent case
              placement_density_diff.png
              routing_congestion_diff.png
            overlays/
              critical_paths.png
              hotspots.png

          logs/
            openroad.log
            eco_execution.log
          safety_trace.json        # rail checks, failure classifications

    comparisons/                   # cross-case comparisons
      stage_0_survivors.json
      stage_1_survivors.json
      final_comparison.json

    visualizations/                # study-level visualizations
      pareto_frontier.png
      pareto_evolution.gif
      improvement_trajectory.png
      stage_progression.png
```

All schemas are additive and backward-compatible.

---

## Visualization System

Noodle 2 treats visualization as a **first-class, high-priority feature**. Visual evidence is essential for understanding *where* and *why* ECOs succeed or fail.

### Visualization Modes

| Mode | Description | When Used |
|------|-------------|-----------|
| **Headless (MVP)** | Xvfb-based, fully automated | Ray workers, CI, production |
| **Interactive (Follow-up)** | X11 passthrough, manual exploration | Developer workstations |

### Heatmap Types

| Heatmap | Description | Primary Use |
|---------|-------------|-------------|
| `placement_density` | Cell distribution across die | Identify placement hotspots |
| `routing_congestion` | Post-GR wire density | Identify routing bottlenecks |
| `rudy` | Rectangular Uniform wire Density | Pre-GR congestion estimate |
| `power_density` | Power consumption distribution | IR drop correlation |
| `timing_slack` | Slack distribution (custom) | Critical region identification |

### Headless Execution (MVP)

```bash
# Inside container with Xvfb
Xvfb :99 -screen 0 1024x768x24 &
export DISPLAY=:99

openroad -gui -exit <<EOF
source load_design.tcl

# Placement density
gui::select_heatmap "Placement Density"
gui::dump_heatmap placement_density heatmaps/placement_density.csv

# Routing congestion (requires global_route first)
global_route -congestion_report_file congestion_report.txt
gui::select_heatmap "Routing Congestion"
gui::dump_heatmap routing_congestion heatmaps/routing_congestion.csv

# RUDY
gui::select_heatmap "RUDY"
gui::dump_heatmap rudy heatmaps/rudy.csv
EOF
```

### Differential Heatmaps

Noodle 2 generates **differential heatmaps** showing changes between cases:

```
Before ECO:                After ECO:               Difference:
┌─────────────────┐       ┌─────────────────┐       ┌─────────────────┐
│    ░░░░░░░      │       │    ░░░          │       │    ▼▼▼          │
│  ░░████████░░   │  -->  │  ░░██████░░     │  ==>  │  ░░▼▼▼▼▼▼░░     │
│  ░░████████░░   │       │  ░░████░░░░     │       │  ░░▼▼▼▼░░░░     │
│    ░░░░░░░      │       │    ░░░░         │       │    ▼▼▼▼         │
└─────────────────┘       └─────────────────┘       └─────────────────┘
  (congested)               (improved)              (green = better)
```

**Differential Output**:

```
visualizations/
  differential/
    placement_density_diff.csv      # raw diff values
    placement_density_diff.png      # red=worse, green=better
    routing_congestion_diff.csv
    routing_congestion_diff.png
    improvement_summary.json        # quantified improvements per region
```

**Improvement Summary**:

```json
{
  "differential_summary": {
    "placement_density": {
      "improved_bins": 234,
      "worsened_bins": 12,
      "unchanged_bins": 854,
      "net_improvement_pct": 18.5,
      "max_improvement_region": {"x": 150, "y": 200, "delta": -0.35}
    },
    "routing_congestion": {
      "improved_bins": 456,
      "worsened_bins": 23,
      "unchanged_bins": 621,
      "net_improvement_pct": 31.2,
      "resolved_hotspots": [1, 3],
      "new_hotspots": []
    }
  }
}
```

### Critical Path Overlay

Noodle 2 generates heatmaps with **critical path overlays**:

```
┌─────────────────────────────────────────┐
│                                         │
│    ░░░░░░░░░░░░░░░                     │
│  ░░████████████░░░░     ══════════╗    │
│  ░░██████████████░░░    ║ path 1  ║    │
│  ░░████████████░░░░     ════════╦═╝    │
│    ░░░░░░░░░░░░░              ║        │
│         ╔═══════════════════╦═╝        │
│         ║      path 2       ║          │
│         ╚═══════════════════╝          │
│                                         │
└─────────────────────────────────────────┘
  Routing Congestion + Top 5 Critical Paths
```

**Overlay Configuration**:

```yaml
visualization:
  critical_path_overlay:
    enabled: true
    path_count: 10
    color_by: slack              # "slack", "wire_delay", or "cell_delay"
    show_endpoints: true
    show_slack_labels: true
```

### Hotspot Annotation

Heatmaps include **automatic hotspot annotation**:

```
┌─────────────────────────────────────────┐
│                                         │
│    ░░░░░░░░░░░░░░░                     │
│  ░░████████████░░░░   ┌─────────────┐  │
│  ░░██[HS-1]████░░░░   │ HS-1: 0.92  │  │
│  ░░████████████░░░░   │ cause: pins │  │
│    ░░░░░░░░░░░░░      └─────────────┘  │
│                                         │
│         ████████   ┌─────────────┐     │
│       ██[HS-2]██   │ HS-2: 0.78  │     │
│         ████████   │ cause: density│    │
│                    └─────────────┘     │
└─────────────────────────────────────────┘
```

### Pareto Frontier Visualization

For multi-objective optimization, Noodle 2 visualizes the **Pareto frontier**:

```
Hot Ratio
    │
0.4 │     ×
    │   ×   ×
0.3 │ ×       ×
    │   ●───────●     ← Pareto frontier
0.2 │     ●       ●
    │       ●───────●
0.1 │           ●
    │             ●
0.0 └─────────────────────
    -3000  -2000  -1000   0   WNS (ps)

    × = dominated solutions
    ● = Pareto-optimal solutions
    ─ = frontier boundary
```

**Pareto Evolution Animation**:

Noodle 2 generates an animated GIF showing frontier evolution across stages:

```
visualizations/
  pareto_frontier_stage_0.png
  pareto_frontier_stage_1.png
  pareto_frontier_stage_2.png
  pareto_evolution.gif            # animated progression
```

### Improvement Trajectory

Track metric improvement over the study:

```
WNS (ps)
    │
   0│                                    ●────
    │                               ●────
-500│                          ●────
    │                     ●────
-1000│               ●────
    │          ●────
-1500│     ●────
    │●────
-2000│
    └────────────────────────────────────────
         S0    S1    S2    S3    Final

    Stage Progression with Best/Median/Worst
```

### Stage Progression Visualization

```
Stage 0: Exploration          Stage 1: Refinement         Stage 2: Closure
┌─────────────────────┐      ┌─────────────────────┐     ┌─────────────────┐
│ 50 trials           │      │ 30 trials           │     │ 10 trials       │
│ 10 survivors        │ ──▶  │ 3 survivors         │ ──▶ │ 1 winner        │
│                     │      │                     │     │                 │
│ WNS: -2150 → -1200  │      │ WNS: -1200 → -650   │     │ WNS: -650 → -320│
│ Hot:  0.35 →  0.22  │      │ Hot:  0.22 →  0.12  │     │ Hot: 0.12 → 0.08│
└─────────────────────┘      └─────────────────────┘     └─────────────────┘
```

### Visualization Contract

For any stage with visualization enabled, the **minimum required set** is:

| Artifact | Format | Required |
|----------|--------|----------|
| `placement_density` | CSV + PNG | Yes |
| `routing_congestion` | CSV + PNG | Yes |
| `differential` (if parent exists) | PNG | Yes |
| `hotspot_annotations` | JSON + PNG | Yes |
| `critical_path_overlay` | PNG | If timing issue |
| `pareto_frontier` | PNG | If multi-objective |

**Fallback Behavior**:

1. If heatmap generation fails: log `visualization_unavailable`, continue trial
2. If differential fails: skip differential, generate absolute heatmaps only
3. Mark `artifact_index.json` with `visualization_status` field

---

## Ray Dashboard Integration

### Feature: Ray Dashboard as the Operator Console

**Capability**

* Noodle 2 runs on Ray and exposes the **Ray Dashboard** as the default operator UI.
* Operators can observe:
  * cluster health and node status
  * running / completed trial tasks per stage
  * per-stage throughput, failures, and resource utilization

**Single-node execution (MVP)**:

```bash
ray start --head --dashboard-host=0.0.0.0
# Dashboard available at http://localhost:8265
```

### Feature: Trial Artifact Indexing and Deep Links

**Capability**

* Every trial produces an **artifact bundle** in a deterministic location.
* Noodle 2 emits an **artifact index** (`artifact_index.json`) per trial containing:
  * paths to key files (reports, logs, JSON metrics)
  * paths to all visualization artifacts
  * high-level labels (ECO name, stage index, derived case id)
  * visualization status and available heatmaps

**Artifact Index Schema**:

```json
{
  "trial_id": "nangate45_1_5_t003",
  "case": "nangate45_1_5",
  "stage": 1,
  "eco_applied": "resize_critical_drivers",
  "eco_parameters": {"size_multiplier": 1.5, "max_paths": 10},

  "metrics": {
    "wns_ps": -850,
    "tns_ps": -12000,
    "hot_ratio": 0.15
  },

  "metrics_delta": {
    "wns_ps": +350,
    "tns_ps": +8000,
    "hot_ratio": -0.07
  },

  "visualization_status": "complete",
  "visualizations": {
    "heatmaps": {
      "placement_density": "visualizations/heatmaps/placement_density.png",
      "routing_congestion": "visualizations/heatmaps/routing_congestion.png"
    },
    "differential": {
      "placement_density_diff": "visualizations/differential/placement_density_diff.png",
      "routing_congestion_diff": "visualizations/differential/routing_congestion_diff.png"
    },
    "overlays": {
      "critical_paths": "visualizations/overlays/critical_paths.png",
      "hotspots": "visualizations/overlays/hotspots.png"
    }
  },

  "diagnosis": "diagnosis.json",
  "timing_report": "timing_report.txt",
  "congestion_report": "congestion_report.txt",
  "logs": ["logs/openroad.log", "logs/eco_execution.log"],
  "safety_trace": "safety_trace.json"
}
```

---

## Study Comparison

Noodle 2 supports comparing two studies to understand what worked better:

```bash
noodle2 compare --study1 nangate45_v1 --study2 nangate45_v2
```

**Comparison Output**:

```
Study Comparison: nangate45_v1 vs nangate45_v2
══════════════════════════════════════════════════════════════════

Overall Metrics:
─────────────────────────────────────────────────────────────────
Metric                  v1            v2            Delta
─────────────────────────────────────────────────────────────────
Final WNS (ps)          -850          -620          +27.1%  ▲
Final TNS (ps)          -12000        -8500         +29.2%  ▲
Final hot_ratio         0.12          0.08          +33.3%  ▲
Total trials            156           98            -37.2%  ▲
Successful trials       142           89            -37.3%
ECO success rate        68%           75%           +7.0%   ▲
Runtime (min)           45            32            -28.9%  ▲
Stages to converge      4             3             -25.0%  ▲

ECO Effectiveness:
─────────────────────────────────────────────────────────────────
ECO                           v1 success    v2 success    Delta
─────────────────────────────────────────────────────────────────
resize_critical_drivers       72%           85%           +13%  ▲
insert_buffers                65%           70%           +5%   ▲
spread_dense_region           58%           62%           +4%   ▲
reroute_congested_nets        45%           48%           +3%

Key Differences:
─────────────────────────────────────────────────────────────────
• v2 used warm_start from v1 priors (explains higher ECO success)
• v2 used diverse_top_n selection (explains fewer trials needed)
• v2 enabled auto-diagnosis (explains better ECO targeting)

Visualization: comparison_v1_v2/
  pareto_comparison.png
  trajectory_comparison.png
  eco_effectiveness_comparison.png
```

---

## What Noodle 2 Enables

Noodle 2 is designed for:

* unattended, long-running PD experiments
* CI and regression safety checks
* comparative ECO studies
* reproducible demos on open PDKs
* controlled integration of future AI planners

It provides **confidence and control**, not just speed.

---

## Implementation & Platform

### Language & Runtime

**Noodle 2 is implemented in Python.**

* Python 3.10+ is the supported runtime.
* Core responsibilities (policy evaluation, safety logic, telemetry aggregation, case graph management) are pure-Python and deterministic.
* No PD algorithms are reimplemented in Python; all physical design computation is delegated to external tools.

This choice optimizes for:

* rapid iteration and testability
* rich orchestration and policy logic
* straightforward integration with distributed execution frameworks

---

### EDA Tooling & Container Baseline

Noodle 2 executes all physical-design work inside a **standardized Docker container**.

**Primary supported image**:

```
openroad/orfs:latest
```

Alternative images for specific use cases:

```
efabless/openlane:latest          # Sky130-focused workflows
openroad/flow-ubuntu22.04-dev     # Development/debugging
```

Container requirements:

* OpenROAD and OpenSTA on PATH
* `report_checks` for timing analysis
* `global_route -congestion_report_file` for congestion metrics
* Xvfb for headless GUI operations
* Python 3 with matplotlib/numpy for heatmap rendering
* PDK files for target technologies

All tool invocations are executed via Docker wrappers; Noodle 2 does **not** require native OpenROAD installations on the host.

---

### PDK Availability

Noodle 2 supports three reference PDK targets in priority order:

| Priority | PDK | Source | Notes |
|----------|-----|--------|-------|
| 1 | **Nangate45** | OpenROAD-flow-scripts | Fastest iteration, primary bring-up target |
| 2 | **ASAP7** | OpenROAD-flow-scripts | Advanced-node stress testing |
| 3 | **Sky130** | efabless/OpenLane | Production-realistic, fully open |

**PDK paths are resolved inside the container.** No network access is required at runtime.

If a Study requires a modified PDK, it must be introduced via:

* a custom container image, or
* a bind-mounted, versioned PDK override declared in the Study definition

Implicit or ad-hoc PDK replacement is not permitted.

---

### Execution Model

Noodle 2 separates concerns cleanly:

* **Controller layer (Python)** — runs outside the container
* **Trial execution layer (Docker)** — runs OpenROAD/OpenSTA inside the container

Each trial:

* executes in an isolated working directory
* consumes an immutable snapshot
* emits structured artifacts (metrics, logs, reports, visualizations)
* is side-effect free with respect to the base snapshot

This guarantees reproducibility and safe parallelism.

---

### Distributed Orchestration (Ray)

Noodle 2 uses **Ray** as its execution and scheduling substrate.

* Ray provides task-level parallelism for trials within a stage.
* The controller submits trials as Ray tasks with explicit resource requirements.
* Ray's object store is used only for lightweight metadata; all heavy artifacts are written to disk.

**Single-node execution (MVP)**:

For development and demos, single-node Ray execution is the primary mode:

```bash
ray start --head --dashboard-host=0.0.0.0
# Dashboard available at http://localhost:8265
```

**Multi-node support (follow-up)**:

* Noodle 2 supports Ray clusters spanning multiple nodes.
* A shared filesystem (e.g., NFS) is assumed for snapshots and artifacts.
* Multi-node validation is deferred until single-node MVP is stable.

Ray is used strictly as an orchestration engine; it does not participate in policy decisions or safety logic.

---

### Determinism & Reproducibility

Noodle 2 enforces determinism by design:

* no random scheduling decisions in the controller
* stable policy rule ordering
* explicit stage and budget configuration
* fixed OpenROAD random seeds (configurable)
* deterministic survivor selection (with optional diversity randomness seeded)

Given the same Study definition, snapshot, and configuration, Noodle 2 produces equivalent outcomes.

---

## Reference Studies & Validation Gates

### PDK Priority Order

Development and validation follow strict priority order:

1. **Nangate45** — must work first, fastest iteration
2. **ASAP7** — must work second, validates advanced-node handling
3. **Sky130** — must work third, validates production-realistic flows

**Non-negotiable rule**: If any higher-priority PDK regresses, development stops until restored.

---

### Mandatory Smoke Tests

Before any higher-level tests, Noodle 2 must pass these smoke tests:

**Test 1: Nangate45 base case**

```bash
noodle2 run --study nangate45_smoke --eco noop
# Expected: rc=0, wns_ps present, artifacts created, heatmaps generated
```

**Test 2: ASAP7 base case**

```bash
noodle2 run --study asap7_smoke --eco noop
# Expected: rc=0, wns_ps present, artifacts created, heatmaps generated
# Note: ASAP7 workarounds automatically applied
```

**Test 3: Sky130 base case**

```bash
noodle2 run --study sky130_smoke --eco noop
# Expected: rc=0, wns_ps present, artifacts created, heatmaps generated
```

Each test must:

* launch the standard container
* execute a base Study with a no-op ECO
* confirm: `rc == 0`, timing report parsed, artifacts created
* generate all required visualizations
* complete within 5 minutes

**Failure semantics**: Any smoke test failure blocks all downstream development.

---

### Development Validation Ladder

Noodle 2 follows a strict, staged validation ladder:

**Gate 0 — Baseline viability (must pass, else stop)**

For each PDK (in priority order: Nangate45, ASAP7, Sky130):

* Base Case runs inside container
* Produces required reports/artifacts
* Generates all required heatmaps
* Satisfies early-failure and telemetry contracts

**Gate 1 — Full output contract**

Each Base Case produces:

* **Monitoring**: tool return code, timestamps, snapshot hash
* **Timing**: `report_checks` parsed into `wns_ps`, `tns_ps`
* **Congestion**: `global_route -congestion_report_file` parsed into `bins_total`, `bins_hot`, `hot_ratio`
* **Diagnosis**: auto-diagnosis report with issue classification
* **Visualization**: all required heatmaps (placement_density, routing_congestion)
* **Early-failure**: deterministic classification (type/severity/reason)
* **Telemetry**: stage- and case-indexed aggregates
* **Audit**: run legality report + safety trace

**Gate 2 — Controlled failure injection**

Demonstrate correct detection/containment of:

* Worsening slack (more negative WNS)
* Localized congestion hotspots
* Deliberate ECOs that trigger tool errors
* Visualization failures (graceful degradation)

**Gate 3 — Cross-target parity**

Same contracts hold across all three PDKs.

**Gate 4 — Extreme scenarios (demo-grade)**

System handles adversarial conditions while:

* Preserving safety and auditability
* Generating complete visualizations
* Producing compelling before/after comparisons

---

### Required Base Cases

| Case Name | PDK | Design | Purpose |
|-----------|-----|--------|---------|
| `nangate45_base` | Nangate45 | GCD or AES | Fast bring-up, CI smoke |
| `asap7_base` | ASAP7 | GCD | Advanced-node validation |
| `sky130_base` | Sky130 | Ibex | Production-realistic demo |

Each Base Case may be "broken" (negative slack, congestion), but must be **structurally runnable**.

---

### Case Naming Convention

All Cases follow deterministic naming:

```
<pdk>_<stage>_<derived>
```

Examples:

* `nangate45_0_0` — Nangate45 base, stage 0
* `asap7_1_5` — ASAP7 stage 1, derived case 5
* `sky130_2_0` — Sky130 stage 2, first case

---

## Platform-Specific Configuration

### ASAP7 Required Workarounds

ASAP7 requires specific configuration for stable operation:

**1. Explicit routing layers**

```tcl
set_routing_layers -signal metal2-metal9 -clock metal6-metal9
```

**2. Explicit floorplan site**

```tcl
initialize_floorplan \
  -utilization 0.55 \
  -site asap7sc7p5t_28_R_24_NP_162NW_34O
```

**3. Restricted pin placement**

```tcl
place_pins -random \
  -hor_layers {metal4} \
  -ver_layers {metal5}
```

**4. STA-first staging**

* Stage 1: STA-only baseline
* Stage 2+: Congestion analysis enabled after design is stable

**5. Lower utilization target**

* Recommended: 0.50-0.55 (vs 0.60-0.70 for Nangate45)

**Memory anchor**: ASAP7 is "timing-driven, high-metal, low-utilization, STA-first."

---

### Sky130 Configuration

Sky130 uses the **sky130A** variant from the OpenLane ecosystem.

```tcl
# Standard Sky130 configuration
set PDK sky130A
set STD_CELL_LIBRARY sky130_fd_sc_hd
```

---

### Nangate45 Configuration

Nangate45 is the most permissive PDK with minimal special handling.

```tcl
# Standard Nangate45 configuration
# No special workarounds required
```

---

## Extreme Case Generation

### Definition

A case is "extreme" if it reliably produces:

* **Routing pressure**: high overflow / hot-bin ratio from global router
* **Timing pressure**: meaningfully negative WNS with diagnosable cause
* **Determinism**: reproducible failure signature across runs

### Core Techniques

**Congestion amplifiers**:

1. High utilization (0.80-0.88)
2. Routing layer restriction (e.g., metal2-metal4 only)
3. Placement blockages (force routing corridors)
4. Pin crowding (cluster I/O on one edge)

**Timing amplifiers**:

1. Tight clock period
2. Stretched floorplan (wire-dominated paths)
3. Minimal buffering in baseline

### Extreme Case Recipes

**Nangate45 Extreme**:

```yaml
design: AES
utilization: 0.85
core_space: 3
routing_layers: metal2-metal4
pin_placement: north_edge_clustered
blockages:
  - center_horizontal_strip

expected_metrics:
  wns_ps: -2000 to -3000
  hot_ratio: 0.30 to 0.45
```

**ASAP7 Extreme**:

```yaml
design: Ibex
utilization: 0.70
clock_period: 1.0ns
routing_layers: metal2-metal7
blockages:
  - center_corridor

expected_metrics:
  wns_ps: -1500 to -2500
  hot_ratio: 0.25 to 0.40
```

**Sky130 Extreme**:

```yaml
design: Ibex
utilization: 0.75
clock_period: 10ns
pin_placement: north_edge_clustered
blockages:
  - routing_chokepoint

expected_metrics:
  wns_ps: -2500 to -4000
  hot_ratio: 0.30 to 0.50
```

---

## Demo Requirements

### End-to-End Demo Specification

The final deliverable is a set of demo scripts that showcase Noodle 2 fixing extremely broken designs.

**Demo 1: Nangate45 Extreme -> Fixed**

```bash
./demo_nangate45_extreme.sh
```

Demonstrates:

* Starting state: WNS ~ -2000ps, hot_ratio > 0.3
* Auto-diagnosis identifying timing vs congestion issues
* Multi-stage ECO application (3+ stages)
* Early failure detection and containment
* Artifact generation (timing reports, congestion reports)
* Full visualization suite (heatmaps, differentials, overlays)
* Pareto frontier tracking (WNS vs hot_ratio)
* Final state: WNS improved by >50%, hot_ratio < 0.1
* Summary report with improvement trajectory

**Demo 2: ASAP7 Extreme -> Fixed**

```bash
./demo_asap7_extreme.sh
```

Demonstrates:

* ASAP7-specific workarounds automatically applied
* Advanced-node timing challenges
* STA-first staging strategy
* Auto-diagnosis guiding ECO selection
* Complete visualization suite
* Improvement from extreme to acceptable

**Demo 3: Sky130 Extreme -> Fixed**

```bash
./demo_sky130_extreme.sh
```

Demonstrates:

* Production-realistic design (Ibex)
* Full observability stack
* Complete audit trail
* Human approval gate (simulated)
* Final comparison visualizations

### Demo Output Requirements

Each demo must produce:

```
demo_output/
  <pdk>_extreme_demo/
    summary.json                    # Overall improvement metrics
    study_log.txt                   # Human-readable execution log
    study_config.yaml               # Frozen study definition

    diagnosis/                      # Auto-diagnosis reports
      initial_diagnosis.json
      stage_0_diagnosis.json
      stage_1_diagnosis.json
      final_diagnosis.json

    before/                         # Initial state (extreme)
      metrics.json
      diagnosis.json
      timing_report.txt
      congestion_report.txt
      heatmaps/
        placement_density.png
        routing_congestion.png
        rudy.png
      overlays/
        critical_paths.png
        hotspots.png

    stages/                         # Per-stage progression
      stage_0/
        stage_summary.json
        survivors/
          case_0_0/
            metrics.json
            heatmaps/
            differential/           # vs initial
          case_0_1/
            ...
        pareto_frontier.png
      stage_1/
        ...
        differential/               # vs stage_0 best
      stage_N/
        ...

    after/                          # Final state (fixed)
      metrics.json
      diagnosis.json
      timing_report.txt
      congestion_report.txt
      heatmaps/
        placement_density.png
        routing_congestion.png
      overlays/
        critical_paths.png          # should show resolved paths

    comparison/                     # Before/after comparison
      before_after_heatmaps/
        placement_density_before.png
        placement_density_after.png
        placement_density_diff.png
        routing_congestion_before.png
        routing_congestion_after.png
        routing_congestion_diff.png
      timing_improvement.png        # WNS trajectory graph
      congestion_improvement.png    # Hot ratio trajectory graph
      pareto_evolution.gif          # Animated Pareto frontier
      stage_progression.png         # Stage-by-stage summary
      summary_table.txt             # Side-by-side metrics

    eco_analysis/                   # ECO effectiveness analysis
      eco_success_rates.json
      eco_effectiveness_chart.png
      recommended_playbook.json     # learned optimal ECO ordering
```

### Demo Success Criteria

| Metric | Nangate45 | ASAP7 | Sky130 |
|--------|-----------|-------|--------|
| WNS improvement | > 50% | > 40% | > 50% |
| Hot ratio reduction | > 60% | > 50% | > 60% |
| Early failures detected | >= 1 | >= 1 | >= 1 |
| Artifacts complete | 100% | 100% | 100% |
| Heatmaps generated | All | All | All |
| Differential heatmaps | Yes | Yes | Yes |
| Critical path overlay | Yes | Yes | Yes |
| Pareto frontier | Yes | Yes | Yes |
| Improvement trajectory | Yes | Yes | Yes |
| Runtime | < 30 min | < 60 min | < 45 min |

### Demo Visualization Checklist

Each demo must include these visualizations:

**Required Heatmaps** (before, after, and differential):
- [ ] placement_density
- [ ] routing_congestion
- [ ] rudy (before and after only)

**Required Overlays**:
- [ ] critical_paths (top 10 paths on layout)
- [ ] hotspots (annotated congestion regions)

**Required Charts**:
- [ ] WNS improvement trajectory
- [ ] Hot ratio improvement trajectory
- [ ] Pareto frontier (final)
- [ ] Pareto evolution (animated GIF)
- [ ] Stage progression summary
- [ ] ECO success rate chart

**Required Comparisons**:
- [ ] Side-by-side before/after metrics table
- [ ] Differential heatmap summary (bins improved/worsened)

---

## ECO Playbook (Fixing Rules)

Noodle 2 includes a standard ECO playbook for demonstration purposes.

### ECO Categories

**Timing ECOs** (address negative WNS):

| ECO Name | Class | Description | Precondition |
|----------|-------|-------------|--------------|
| `resize_critical_drivers` | `placement_local` | Upsize cells on critical paths | timing issue, cell-dominated |
| `insert_buffers` | `placement_local` | Add buffers to long nets | timing issue, wire-dominated |
| `swap_to_faster_cells` | `placement_local` | Replace cells with faster variants | timing issue |
| `restructure_critical_logic` | `routing_affecting` | Restructure timing-critical cones | severe timing, routing slack |

**Congestion ECOs** (address high hot_ratio):

| ECO Name | Class | Description | Precondition |
|----------|-------|-------------|--------------|
| `spread_dense_region` | `placement_local` | Reduce local placement density | congestion issue, density correlated |
| `reroute_congested_nets` | `routing_affecting` | Find alternative routing paths | congestion issue, specific hotspot |
| `add_routing_blockages` | `routing_affecting` | Guide router away from hotspots | congestion issue |
| `macro_channel_widening` | `global_disruptive` | Increase spacing around macros | congestion near macros |

**Combined ECOs** (address both):

| ECO Name | Class | Description | Precondition |
|----------|-------|-------------|--------------|
| `spread_and_rebuffer` | `placement_local` | Spread + insert buffers | both issues, correlated regions |
| `timing_aware_spreading` | `routing_affecting` | Spread while preserving timing | both issues |

### ECO Application Order

Standard playbook ordering driven by auto-diagnosis:

```
Stage 0: Exploration (diagnosis-driven)
  - Run auto-diagnosis
  - Identify primary issue (timing vs congestion)
  - Apply topology_neutral ECOs to characterize

Stage 1: Targeted Fixes (diagnosis-driven)
  IF primary_issue == "timing":
    IF bottleneck == "wire_dominated":
      - insert_buffers (priority 1)
      - spread_dense_region (priority 2)
    ELSE:  # cell_dominated
      - resize_critical_drivers (priority 1)
      - swap_to_faster_cells (priority 2)

  IF primary_issue == "congestion":
    IF cause == "placement_density":
      - spread_dense_region (priority 1)
    IF cause == "pin_crowding":
      - reroute_congested_nets (priority 1)

Stage 2: Refinement
  - Re-run diagnosis
  - Apply secondary ECOs based on residual issues
  - routing_affecting ECOs if needed

Stage 3: Closure
  - Conservative ECOs only
  - Verify no regressions via differential heatmaps
```

---

## Explicit Non-Goals

Noodle 2 intentionally does **not**:

* invent ECOs (ECOs are provided by humans or external tools)
* replace OpenROAD algorithms
* modify PD tool internals
* rely on opaque optimization or ML
* silently escalate risk

All behavior is declarative, inspectable, and auditable.

---

## Summary

Noodle 2 transforms physical-design experimentation from ad-hoc scripting into a **safety-critical, policy-driven system**.

It enables engineers to:

* explore aggressively when appropriate
* close conservatively when required
* always understand *why* a decision was made
* **see exactly where** improvements happened via comprehensive visualization

Noodle 2 is not an optimizer. It is the control plane that makes optimization trustworthy at scale.

The demo deliverables prove this by taking three extremely broken designs (Nangate45, ASAP7, Sky130) and systematically fixing them through:

* **Auto-diagnosis** identifying root causes
* **Multi-stage ECO application** with intelligent selection
* **Full observability** including heatmaps, overlays, and differentials
* **Pareto optimization** balancing timing and congestion
* **Early failure detection** and graceful containment
* **Auditable improvement metrics** with compelling visualizations

The result: broken designs become fixed designs, with visual proof at every step.

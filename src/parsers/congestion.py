"""Parser for OpenROAD global route congestion reports."""

import re
from pathlib import Path
from typing import Optional

from controller.types import CongestionMetrics


def parse_congestion_report(report_content: str) -> CongestionMetrics:
    """
    Parse OpenROAD global route congestion report.

    The report is generated by:
        global_route -congestion_report_file <file>

    Expected format includes lines like:
        Total bins: 12345
        Overflow bins: 234
        Bins with overflow > 20%: 45

    Or similar variants with different wording.

    Args:
        report_content: Content of congestion report file

    Returns:
        CongestionMetrics with hot bin counts

    Raises:
        ValueError: If report cannot be parsed
    """
    lines = report_content.strip().split("\n")

    bins_total: Optional[int] = None
    bins_hot: Optional[int] = None
    max_overflow: Optional[int] = None
    layer_metrics: dict[str, int] = {}

    for line in lines:
        line = line.strip()
        if not line:
            continue

        # Parse total bins
        # Matches: "Total bins: 12345" or "total bins = 12345"
        if match := re.search(r"total\s+bins[:\s=]+(\d+)", line, re.IGNORECASE):
            bins_total = int(match.group(1))

        # Parse overflow/hot bins
        # Matches various formats:
        #   "Overflow bins: 234"
        #   "Hot bins: 234"
        #   "Bins with overflow: 234"
        elif match := re.search(
            r"(overflow|hot)\s+bins[:\s=]+(\d+)", line, re.IGNORECASE
        ):
            bins_hot = int(match.group(2))

        # Alternative format: "Bins with overflow > X%: 234"
        # Match the number after the colon, not the percentage
        elif match := re.search(
            r"bins\s+with\s+overflow[^:]*:\s*(\d+)", line, re.IGNORECASE
        ):
            if bins_hot is None:  # Don't override if already found
                bins_hot = int(match.group(1))

        # Parse max overflow
        # Matches: "Max overflow: 567" or "Maximum overflow = 567"
        elif match := re.search(
            r"max(?:imum)?\s+overflow[:\s=]+(\d+)", line, re.IGNORECASE
        ):
            max_overflow = int(match.group(1))

        # Parse per-layer metrics
        # Matches: "Layer metal3 overflow: 45"
        elif match := re.search(
            r"layer\s+(\w+)\s+overflow[:\s=]+(\d+)", line, re.IGNORECASE
        ):
            layer_name = match.group(1)
            overflow = int(match.group(2))
            layer_metrics[layer_name] = overflow

    # Validate required fields
    if bins_total is None:
        raise ValueError("Could not parse total bins from congestion report")

    if bins_hot is None:
        # Default to 0 if not found (means no congestion)
        bins_hot = 0

    # Calculate hot ratio
    hot_ratio = bins_hot / bins_total if bins_total > 0 else 0.0

    return CongestionMetrics(
        bins_total=bins_total,
        bins_hot=bins_hot,
        hot_ratio=hot_ratio,
        max_overflow=max_overflow,
        layer_metrics=layer_metrics,
    )


def parse_congestion_report_file(file_path: str) -> CongestionMetrics:
    """
    Parse congestion report from file.

    Args:
        file_path: Path to congestion report file

    Returns:
        CongestionMetrics

    Raises:
        FileNotFoundError: If file doesn't exist
        ValueError: If report cannot be parsed
    """
    path = Path(file_path)
    if not path.exists():
        raise FileNotFoundError(f"Congestion report not found: {file_path}")

    content = path.read_text()
    return parse_congestion_report(content)


def parse_congestion_json(json_data: dict) -> CongestionMetrics:
    """
    Parse congestion metrics from JSON format.

    This supports the structured JSON output that some OpenROAD
    versions can produce.

    Args:
        json_data: Dictionary with congestion data

    Returns:
        CongestionMetrics

    Raises:
        ValueError: If required fields are missing
    """
    try:
        bins_total = json_data["bins_total"]
        bins_hot = json_data.get("bins_hot", json_data.get("overflow_bins", 0))

        hot_ratio = bins_hot / bins_total if bins_total > 0 else 0.0

        return CongestionMetrics(
            bins_total=bins_total,
            bins_hot=bins_hot,
            hot_ratio=hot_ratio,
            max_overflow=json_data.get("max_overflow"),
            layer_metrics=json_data.get("layer_metrics", {}),
        )
    except KeyError as e:
        raise ValueError(f"Missing required field in congestion JSON: {e}") from e


def format_congestion_summary(metrics: CongestionMetrics) -> str:
    """
    Format congestion metrics as human-readable summary.

    Args:
        metrics: CongestionMetrics to format

    Returns:
        Human-readable summary string
    """
    lines = []
    lines.append(f"Total bins: {metrics.bins_total}")
    lines.append(f"Hot bins: {metrics.bins_hot}")
    lines.append(f"Hot ratio: {metrics.hot_ratio:.1%}")

    if metrics.max_overflow is not None:
        lines.append(f"Max overflow: {metrics.max_overflow}")

    if metrics.layer_metrics:
        lines.append("\nPer-layer overflow:")
        for layer, overflow in sorted(metrics.layer_metrics.items()):
            lines.append(f"  {layer}: {overflow}")

    return "\n".join(lines)

"""Power metric extraction from OpenSTA power analysis reports.

This module provides a PowerMetricExtractor that parses power analysis reports
generated by OpenSTA and extracts total power, leakage power, and dynamic power
metrics for design evaluation.
"""

from pathlib import Path
from typing import Any
import re

from .custom_metrics import MetricExtractor


class PowerMetricExtractor(MetricExtractor):
    """Extract power metrics from OpenSTA power analysis reports.

    This extractor parses power reports and extracts:
    - total_power_mw: Total power consumption in milliwatts
    - leakage_power_mw: Static leakage power in milliwatts
    - dynamic_power_mw: Dynamic switching power in milliwatts
    - internal_power_mw: Internal power (optional)
    - switching_power_mw: Switching power (optional)

    Expected report format examples:
        Total Power: 125.3 mW
        Leakage Power: 12.1 mW
        Dynamic Power: 113.2 mW

    Or:
        Group                  Internal  Switching    Leakage      Total
                                  Power      Power      Power      Power
        -----------------------------------------------------------------
        Design                    78.5 mW    34.7 mW    12.1 mW   125.3 mW
    """

    def __init__(self) -> None:
        """Initialize power metric extractor."""
        super().__init__()

    def extract(self, artifact_dir: Path) -> dict[str, Any]:
        """Extract power metrics from trial artifacts.

        Args:
            artifact_dir: Path to trial artifact directory

        Returns:
            Dictionary with power metrics in milliwatts:
            {
                "total_power_mw": 125.3,
                "leakage_power_mw": 12.1,
                "dynamic_power_mw": 113.2,
                "internal_power_mw": 78.5,  # optional
                "switching_power_mw": 34.7   # optional
            }
        """
        # Look for common power report file names
        power_report_files = [
            artifact_dir / "power.rpt",
            artifact_dir / "power_report.txt",
            artifact_dir / "sta_power.rpt",
            artifact_dir / "report_power.txt",
        ]

        metrics: dict[str, Any] = {}

        for report_path in power_report_files:
            if report_path.exists():
                content = report_path.read_text()
                parsed = self._parse_power_report(content)
                metrics.update(parsed)

                # If we found metrics, no need to check other files
                if parsed:
                    break

        return metrics

    def _parse_power_report(self, content: str) -> dict[str, Any]:
        """Parse power metrics from OpenSTA power report content.

        Args:
            content: Text content of power report

        Returns:
            Dictionary of parsed power metrics
        """
        metrics: dict[str, Any] = {}

        # Pattern 1: Simple format "Total Power: 125.3 mW"
        total_match = re.search(
            r"Total\s+Power\s*:\s*(\d+\.?\d*)\s*(mW|W|uW)",
            content,
            re.IGNORECASE
        )
        if total_match:
            value = float(total_match.group(1))
            unit = total_match.group(2).lower()
            metrics["total_power_mw"] = self._convert_to_mw(value, unit)

        # Leakage power
        leakage_match = re.search(
            r"Leakage\s+Power\s*:\s*(\d+\.?\d*)\s*(mW|W|uW)",
            content,
            re.IGNORECASE
        )
        if leakage_match:
            value = float(leakage_match.group(1))
            unit = leakage_match.group(2).lower()
            metrics["leakage_power_mw"] = self._convert_to_mw(value, unit)

        # Dynamic power
        dynamic_match = re.search(
            r"Dynamic\s+Power\s*:\s*(\d+\.?\d*)\s*(mW|W|uW)",
            content,
            re.IGNORECASE
        )
        if dynamic_match:
            value = float(dynamic_match.group(1))
            unit = dynamic_match.group(2).lower()
            metrics["dynamic_power_mw"] = self._convert_to_mw(value, unit)

        # Internal power
        internal_match = re.search(
            r"Internal\s+Power\s*:\s*(\d+\.?\d*)\s*(mW|W|uW)",
            content,
            re.IGNORECASE
        )
        if internal_match:
            value = float(internal_match.group(1))
            unit = internal_match.group(2).lower()
            metrics["internal_power_mw"] = self._convert_to_mw(value, unit)

        # Switching power
        switching_match = re.search(
            r"Switching\s+Power\s*:\s*(\d+\.?\d*)\s*(mW|W|uW)",
            content,
            re.IGNORECASE
        )
        if switching_match:
            value = float(switching_match.group(1))
            unit = switching_match.group(2).lower()
            metrics["switching_power_mw"] = self._convert_to_mw(value, unit)

        # Pattern 2: Table format with columns
        # Look for design row in power table
        # Example: "Design                    78.5 mW    34.7 mW    12.1 mW   125.3 mW"
        table_match = re.search(
            r"(?:Design|chip)\s+(\d+\.?\d*)\s*mW\s+(\d+\.?\d*)\s*mW\s+(\d+\.?\d*)\s*mW\s+(\d+\.?\d*)\s*mW",
            content,
            re.IGNORECASE
        )
        if table_match and "total_power_mw" not in metrics:
            # Usually order is: Internal, Switching, Leakage, Total
            metrics["internal_power_mw"] = float(table_match.group(1))
            metrics["switching_power_mw"] = float(table_match.group(2))
            metrics["leakage_power_mw"] = float(table_match.group(3))
            metrics["total_power_mw"] = float(table_match.group(4))

            # Calculate dynamic power if not present
            if "dynamic_power_mw" not in metrics:
                metrics["dynamic_power_mw"] = (
                    metrics["internal_power_mw"] +
                    metrics["switching_power_mw"]
                )

        # If we have dynamic components but no dynamic total, calculate it
        if "dynamic_power_mw" not in metrics:
            if "internal_power_mw" in metrics and "switching_power_mw" in metrics:
                metrics["dynamic_power_mw"] = (
                    metrics["internal_power_mw"] +
                    metrics["switching_power_mw"]
                )

        # If we have total and leakage but no dynamic, calculate it
        if "total_power_mw" in metrics and "leakage_power_mw" in metrics:
            if "dynamic_power_mw" not in metrics:
                metrics["dynamic_power_mw"] = (
                    metrics["total_power_mw"] -
                    metrics["leakage_power_mw"]
                )

        return metrics

    def _convert_to_mw(self, value: float, unit: str) -> float:
        """Convert power value to milliwatts.

        Args:
            value: Power value
            unit: Power unit (mW, W, uW, μW)

        Returns:
            Power in milliwatts
        """
        unit_lower = unit.lower()

        if unit_lower in ("mw", "milliwatt", "milliwatts"):
            return value
        elif unit_lower in ("w", "watt", "watts"):
            return value * 1000.0  # W to mW
        elif unit_lower in ("uw", "µw", "uwatt", "µwatt", "microwatt", "microwatts"):
            return value / 1000.0  # uW to mW
        else:
            # Assume mW if unknown
            return value

    def validate_metrics(self, metrics: dict[str, Any]) -> bool:
        """Validate extracted power metrics.

        Args:
            metrics: Dictionary of extracted metrics

        Returns:
            True if metrics are valid, False otherwise
        """
        # Call parent validation
        if not super().validate_metrics(metrics):
            return False

        # Additional power-specific validation
        # Check that power values are non-negative
        for key, value in metrics.items():
            if key.endswith("_mw") and isinstance(value, (int, float)):
                if value < 0:
                    return False

        # If we have all three, verify total = leakage + dynamic (within tolerance)
        if all(k in metrics for k in ["total_power_mw", "leakage_power_mw", "dynamic_power_mw"]):
            total = metrics["total_power_mw"]
            leakage = metrics["leakage_power_mw"]
            dynamic = metrics["dynamic_power_mw"]

            expected_total = leakage + dynamic
            # Allow 1% tolerance for rounding errors
            tolerance = max(0.01 * total, 0.001)  # At least 0.001 mW tolerance

            if abs(total - expected_total) > tolerance:
                # Validation warning but don't fail - reports may have rounding
                pass

        return True


def create_power_enabled_registry():
    """Create a metric extractor registry with power analysis enabled.

    Returns:
        MetricExtractorRegistry with power extractor registered
    """
    from .custom_metrics import MetricExtractorRegistry

    registry = MetricExtractorRegistry()
    registry.register("power", PowerMetricExtractor())
    return registry
